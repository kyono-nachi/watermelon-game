<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ウォーターメロンゲーム</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: 'Rounded Mplus 1c', 'Arial', sans-serif;
            background: linear-gradient(180deg, #C8A882 0%, #A67C52 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
            touch-action: none;
        }

        #gameContainer {
            position: relative;
            width: 100vw;
            max-width: 100%;
            height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            gap: 15px;
        }

        #topPanel {
            display: flex;
            justify-content: center;
            gap: 20px;
            width: 100%;
            max-width: 500px;
        }

        .info-bubble {
            background: rgba(255, 248, 230, 0.95);
            border-radius: 50%;
            width: 120px;
            height: 120px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 15px rgba(139, 69, 19, 0.3);
            border: 3px solid rgba(255, 255, 255, 0.5);
            flex-shrink: 0;
        }

        .info-label {
            font-size: 14px;
            color: #8B4513;
            margin-bottom: 5px;
            font-weight: bold;
        }

        .info-value {
            font-size: 28px;
            font-weight: bold;
            color: #D2691E;
        }

        .best-score-label {
            font-size: 10px;
            color: #8B4513;
            opacity: 0.7;
        }

        #nextBall {
            background: rgba(255, 248, 230, 0.95);
            border-radius: 50%;
            width: 120px;
            height: 120px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 15px rgba(139, 69, 19, 0.3);
            border: 3px solid rgba(255, 255, 255, 0.5);
            flex-shrink: 0;
        }

        #nextBall h3 {
            font-size: 14px;
            color: #8B4513;
            margin-bottom: 8px;
            font-weight: bold;
        }

        #nextPreview {
            width: 70px;
            height: 70px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            font-weight: bold;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            overflow: hidden;
        }

        #nextPreview img {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        #gameArea {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            max-width: 500px;
            gap: 10px;
        }

        #canvasWrapper {
            position: relative;
            width: 100%;
            flex-shrink: 0;
        }

        #gameCanvas {
            display: block;
            background: linear-gradient(180deg, #FFF8E7 0%, #F5E6D3 100%);
            border-radius: 15px;
            box-shadow: 
                0 8px 20px rgba(0,0,0,0.2),
                inset 0 2px 5px rgba(255,255,255,0.5);
            border: 4px solid #D2B48C;
            cursor: pointer;
            touch-action: none;
            width: 100%;
        }

        #sinkaBar {
            width: 100%;
            background: rgba(255, 248, 230, 0.95);
            border-radius: 15px;
            padding: 15px;
            box-shadow: 0 4px 15px rgba(139, 69, 19, 0.3);
            border: 3px solid rgba(255, 255, 255, 0.5);
            flex-shrink: 0;
        }

        #sinkaBar h3 {
            font-size: 14px;
            color: #8B4513;
            text-align: center;
            margin-bottom: 10px;
            font-weight: bold;
        }

        #sinkaBarImage {
            width: 100%;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            min-height: 60px;
        }

        #sinkaBarImage img {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        .placeholder-text {
            font-size: 12px;
            color: #8B4513;
            opacity: 0.5;
            text-align: center;
        }

        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 248, 230, 0.98);
            padding: 40px;
            border-radius: 30px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.4);
            text-align: center;
            display: none;
            pointer-events: all;
            border: 3px solid #D2691E;
            z-index: 1000;
        }

        #gameOver h2 {
            font-size: 32px;
            color: #D2691E;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
        }

        #gameOver p {
            font-size: 18px;
            color: #8B4513;
            margin-bottom: 30px;
        }

        #restartBtn {
            background: linear-gradient(135deg, #FFB347 0%, #FF8C42 100%);
            color: white;
            border: none;
            padding: 15px 40px;
            border-radius: 30px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.2s;
            box-shadow: 0 4px 15px rgba(255, 140, 66, 0.4);
            text-shadow: 1px 1px 2px rgba(0,0,0,0.2);
        }

        #restartBtn:active {
            transform: scale(0.95);
        }

        .game-line {
            position: absolute;
            left: 4px;
            right: 4px;
            height: 2px;
            background: rgba(255, 107, 107, 0.6);
            pointer-events: none;
            z-index: 10;
        }

        @media (max-width: 768px) {
            #gameContainer {
                padding: 15px;
            }
            
            .info-bubble, #nextBall {
                width: 100px;
                height: 100px;
            }
            
            .info-label {
                font-size: 12px;
            }
            
            .info-value {
                font-size: 24px;
            }
            
            #nextPreview {
                width: 60px;
                height: 60px;
            }
        }

        @media (max-width: 480px) {
            #gameContainer {
                padding: 10px;
            }
            
            .info-bubble, #nextBall {
                width: 85px;
                height: 85px;
            }
            
            .info-label, #nextBall h3 {
                font-size: 11px;
            }
            
            .info-value {
                font-size: 20px;
            }
            
            .best-score-label {
                font-size: 9px;
            }
            
            #nextPreview {
                width: 50px;
                height: 50px;
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="topPanel">
            <div class="info-bubble">
                <span class="info-label">スコア</span>
                <span class="info-value" id="scoreValue">0</span>
                <span class="best-score-label">BEST SCORE</span>
                <span class="info-value" style="font-size: 16px;" id="worldRecord">5322</span>
            </div>
            <div id="nextBall">
                <h3>ネクスト</h3>
                <div id="nextPreview"></div>
            </div>
        </div>
        <div id="gameArea">
            <div id="canvasWrapper">
                <canvas id="gameCanvas"></canvas>
                <div class="game-line"></div>
                <div id="gameOver">
                    <h2>ゲームオーバー</h2>
                    <p>スコア: <span id="finalScore">0</span></p>
                    <button id="restartBtn">リスタート</button>
                </div>
            </div>
            <div id="sinkaBar">
                <h3>シンカの棒</h3>
                <div id="sinkaBarImage">
                    <span class="placeholder-text">画像を配置</span>
                </div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // ====================
        // 画像設定エリア
        // ====================
        const FRUIT_IMAGES = {
            0: 'images/fruit_0.png',
            1: 'images/fruit_1.png',
            2: 'images/fruit_2.png',
            3: 'images/fruit_3.png',
            4: 'images/fruit_4.png',
            5: 'images/fruit_5.png',
            6: 'images/fruit_6.png',
            7: 'images/fruit_7.png',
            8: 'images/fruit_8.png',
            9: 'images/fruit_9.png',
            10: 'images/fruit_10.png'
        };
        
        // シンカの棒の画像パス
        const SINKA_BAR_IMAGE = 'images/sinka_bar.png';
        
        // ====================
        
        // 画像オブジェクトを格納
        const fruitImageObjects = {};
        let sinkaBarImageObject = null;
        let imagesLoaded = false;
        
        // 画像をプリロード
        function preloadImages() {
            let loadedCount = 0;
            let totalImages = 0;
            
            // フルーツ画像の数をカウント
            for (let key in FRUIT_IMAGES) {
                if (FRUIT_IMAGES[key]) totalImages++;
            }
            
            // シンカの棒画像をカウント
            if (SINKA_BAR_IMAGE) totalImages++;
            
            if (totalImages === 0) {
                imagesLoaded = true;
                return;
            }
            
            function checkAllLoaded() {
                loadedCount++;
                if (loadedCount === totalImages) {
                    imagesLoaded = true;
                }
            }
            
            // フルーツ画像を読み込み
            for (let key in FRUIT_IMAGES) {
                if (FRUIT_IMAGES[key]) {
                    const img = new Image();
                    img.onload = checkAllLoaded;
                    img.onerror = checkAllLoaded;
                    img.src = FRUIT_IMAGES[key];
                    fruitImageObjects[key] = img;
                }
            }
            
            // シンカの棒画像を読み込み
            if (SINKA_BAR_IMAGE) {
                sinkaBarImageObject = new Image();
                sinkaBarImageObject.onload = () => {
                    checkAllLoaded();
                    // UI表示
                    const sinkaBarImg = document.getElementById('sinkaBarImage');
                    sinkaBarImg.innerHTML = '';
                    const imgElement = document.createElement('img');
                    imgElement.src = SINKA_BAR_IMAGE;
                    sinkaBarImg.appendChild(imgElement);
                };
                sinkaBarImageObject.onerror = checkAllLoaded;
                sinkaBarImageObject.src = SINKA_BAR_IMAGE;
            }
        }
        
        preloadImages();
        
        // キャンバスサイズを設定（横1：縦1.1の比率）
        function resizeCanvas() {
            const wrapper = document.getElementById('canvasWrapper');
            const maxWidth = wrapper.clientWidth;
            
            // 横幅を基準に、縦を1.1倍に設定
            canvas.width = maxWidth;
            canvas.height = maxWidth * 1.1;
            
            // ゲームオーバーラインの位置を更新
            const gameLine = document.querySelector('.game-line');
            gameLine.style.top = (canvas.height * 0.15) + 'px';
            
            // シンカの棒の高さを設定（横幅の0.3倍）
            const sinkaBar = document.getElementById('sinkaBar');
            sinkaBar.style.height = (maxWidth * 0.3) + 'px';
        }
        
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        // ゲーム設定
        const GRAVITY = 0.5;
        const BOUNCE = 0.3;
        const FRICTION = 0.99;
        const GAME_LINE_Y_RATIO = 0.15; // キャンバス高さの15%の位置
        const WALL_THICKNESS_RATIO = 0.02; // キャンバス幅の2%
        
        // ゲームオーバーラインの実際のY座標を取得
        function getGameLineY() {
            return canvas.height * GAME_LINE_Y_RATIO;
        }
        
        // 壁の厚さを取得
        function getWallThickness() {
            return canvas.width * WALL_THICKNESS_RATIO;
        }
        
        // フルーツ風のボールの色設定（デフォルトカラー：画像がない場合）
        const BALL_COLORS = [
            '#FFE66D', // 0: チェリー（黄色）
            '#FFB347', // 1: オレンジ
            '#FF6B6B', // 2: ストロベリー（赤）
            '#C77DFF', // 3: グレープ（紫）
            '#FFD93D', // 4: レモン（黄色明るめ）
            '#FF8C42', // 5: ピーチ（オレンジ赤）
            '#4ECDC4', // 6: メロン（ターコイズ）
            '#95E1D3', // 7: ライチ（ミント）
            '#F38181', // 8: アップル（赤）
            '#FFEB3B', // 9: パイナップル（黄色）
            '#FFD700'  // 10: スイカ（ゴールド）
        ];
        
        // ボールのサイズ設定（11個のボール、最大が横幅の45%）
        function getBallSize(type) {
            // 最大サイズ（type 10）が横幅の45%
            const maxSize = canvas.width * 0.45 / 2; // 直径の45%なので半径は22.5%
            // 最小サイズ（type 0）を最大サイズの20%に設定
            const minSize = maxSize * 0.2;
            // 線形に増加
            return minSize + (maxSize - minSize) * (type / 10);
        }
        
        // ゲーム状態
        let balls = [];
        let score = 0;
        let nextBallType = 0;
        let isGameOver = false;
        let currentBall = null;
        let worldRecord = 5322;
        let frameCount = 0;
        let checkGameOverDelay = 0;
        
        // 次のボールをランダムに選択（0-4の範囲）
        function getRandomBallType() {
            return Math.floor(Math.random() * 5);
        }
        
        // ボールクラス
        class Ball {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.radius = getBallSize(type);
                this.vx = 0;
                this.vy = 0;
                this.color = BALL_COLORS[type];
                this.merged = false;
                this.rotation = 0; // 最初は正面向き
                this.angularVelocity = 0;
            }
            
            update() {
                if (this.merged) return;
                
                const wallThickness = getWallThickness();
                
                // 重力を適用
                this.vy += GRAVITY;
                
                // 摩擦を適用
                this.vx *= FRICTION;
                this.vy *= FRICTION;
                
                // 角速度を速度に基づいて更新（転がる効果）
                this.angularVelocity = -this.vx / (this.radius * 0.15); // 転げ落ちる回転
                this.rotation += this.angularVelocity;
                
                // 角速度の減衰（緩やかに）
                this.angularVelocity *= 0.98;
                
                // 位置を更新
                this.x += this.vx;
                this.y += this.vy;
                
                // 壁との衝突
                if (this.x - this.radius < wallThickness) {
                    this.x = wallThickness + this.radius;
                    this.vx *= -BOUNCE;
                }
                if (this.x + this.radius > canvas.width - wallThickness) {
                    this.x = canvas.width - wallThickness - this.radius;
                    this.vx *= -BOUNCE;
                }
                
                // 床との衝突
                if (this.y + this.radius > canvas.height - wallThickness) {
                    this.y = canvas.height - wallThickness - this.radius;
                    this.vy *= -BOUNCE;
                    this.vx *= 0.95; // 床での摩擦
                }
            }
            
            draw() {
                if (this.merged) return;
                
                ctx.save();
                
                // ボールの影
                ctx.fillStyle = 'rgba(139, 69, 19, 0.3)';
                ctx.beginPath();
                ctx.ellipse(this.x + 5, this.y + 5, this.radius * 0.95, this.radius * 0.3, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // 回転を適用
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                
                // 画像がある場合は画像を描画
                if (fruitImageObjects[this.type]) {
                    ctx.drawImage(
                        fruitImageObjects[this.type],
                        -this.radius, -this.radius,
                        this.radius * 2, this.radius * 2
                    );
                } else {
                    // 画像がない場合はデフォルトの描画
                    // ボール本体（グラデーション）
                    const gradient = ctx.createRadialGradient(
                        -this.radius * 0.3, -this.radius * 0.3, 0,
                        0, 0, this.radius
                    );
                    gradient.addColorStop(0, this.lightenColor(this.color, 40));
                    gradient.addColorStop(1, this.color);
                    
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // ボールの縁
                    ctx.strokeStyle = this.darkenColor(this.color, 30);
                    ctx.lineWidth = 3;
                    ctx.stroke();
                    
                    // 回転が非常に分かりやすい放射状のライン（スイカ風）
                    ctx.strokeStyle = this.darkenColor(this.color, 40);
                    ctx.lineWidth = 3;
                    for (let i = 0; i < 6; i++) {
                        const angle = (Math.PI * 2 / 6) * i;
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.lineTo(
                            Math.cos(angle) * this.radius * 0.9,
                            Math.sin(angle) * this.radius * 0.9
                        );
                        ctx.stroke();
                    }
                    
                    // 中央に数字を表示（回転の確認用）
                    ctx.fillStyle = 'white';
                    ctx.font = `bold ${this.radius * 0.6}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(this.type, 0, 0);
                }
                
                ctx.restore();
            }
            
            lightenColor(color, percent) {
                const num = parseInt(color.replace("#",""), 16);
                const amt = Math.round(2.55 * percent);
                const R = (num >> 16) + amt;
                const G = (num >> 8 & 0x00FF) + amt;
                const B = (num & 0x0000FF) + amt;
                return "#" + (0x1000000 + (R<255?R<1?0:R:255)*0x10000 +
                    (G<255?G<1?0:G:255)*0x100 + (B<255?B<1?0:B:255))
                    .toString(16).slice(1);
            }
            
            darkenColor(color, percent) {
                const num = parseInt(color.replace("#",""), 16);
                const amt = Math.round(2.55 * percent);
                const R = (num >> 16) - amt;
                const G = (num >> 8 & 0x00FF) - amt;
                const B = (num & 0x0000FF) - amt;
                return "#" + (0x1000000 + (R>0?R:0)*0x10000 +
                    (G>0?G:0)*0x100 + (B>0?B:0))
                    .toString(16).slice(1);
            }
        }
        
        // ボール同士の衝突判定と処理
        function handleCollisions() {
            const newBalls = [];
            
            for (let i = 0; i < balls.length; i++) {
                if (balls[i].merged) continue;
                
                for (let j = i + 1; j < balls.length; j++) {
                    if (balls[j].merged) continue;
                    
                    const dx = balls[j].x - balls[i].x;
                    const dy = balls[j].y - balls[i].y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const minDist = balls[i].radius + balls[j].radius;
                    
                    if (distance < minDist) {
                        // 同じタイプのボールが衝突 → 合成
                        if (balls[i].type === balls[j].type && balls[i].type < 10) {
                            const newType = balls[i].type + 1;
                            const newX = (balls[i].x + balls[j].x) / 2;
                            const newY = (balls[i].y + balls[j].y) / 2;
                            
                            const newBall = new Ball(newX, newY, newType);
                            newBalls.push(newBall);
                            
                            balls[i].merged = true;
                            balls[j].merged = true;
                            
                            // スコア加算
                            score += Math.pow(2, newType) * 10;
                            updateScore();
                            
                            break;
                        } else {
                            // 物理的な押し出し
                            const overlap = minDist - distance;
                            const angle = Math.atan2(dy, dx);
                            
                            const pushX = Math.cos(angle) * overlap / 2;
                            const pushY = Math.sin(angle) * overlap / 2;
                            
                            balls[i].x -= pushX;
                            balls[i].y -= pushY;
                            balls[j].x += pushX;
                            balls[j].y += pushY;
                            
                            // 速度交換（簡易版）
                            const vx1 = balls[i].vx;
                            const vy1 = balls[i].vy;
                            
                            balls[i].vx = balls[j].vx * 0.8;
                            balls[i].vy = balls[j].vy * 0.8;
                            balls[j].vx = vx1 * 0.8;
                            balls[j].vy = vy1 * 0.8;
                        }
                    }
                }
            }
            
            // マージされたボールを削除
            balls = balls.filter(b => !b.merged);
            
            // 新しいボールを追加
            balls.push(...newBalls);
        }
        
        // ゲームオーバー判定
        function checkGameOver() {
            // ボールが落ちてから少し待つ
            if (checkGameOverDelay > 0) {
                checkGameOverDelay--;
                return false;
            }
            
            const gameLineY = getGameLineY();
            
            for (let ball of balls) {
                // ボールが完全に静止していない場合は判定しない
                if (Math.abs(ball.vy) > 2) {
                    return false;
                }
                
                if (ball.y - ball.radius < gameLineY) {
                    return true;
                }
            }
            return false;
        }
        
        // スコア更新
        function updateScore() {
            document.getElementById('scoreValue').textContent = score;
            if (score > worldRecord) {
                worldRecord = score;
                document.getElementById('worldRecord').textContent = worldRecord;
            }
        }
        
        // 次のボールのプレビュー更新
        function updateNextPreview() {
            const preview = document.getElementById('nextPreview');
            preview.innerHTML = '';
            
            if (fruitImageObjects[nextBallType]) {
                // 画像がある場合
                const img = document.createElement('img');
                img.src = fruitImageObjects[nextBallType].src;
                preview.appendChild(img);
            } else {
                // 画像がない場合はデフォルトカラー
                preview.style.backgroundColor = BALL_COLORS[nextBallType];
                preview.textContent = nextBallType;
            }
        }
        
        // マウス/タッチイベント
        let mouseX = canvas.width / 2;
        
        canvas.addEventListener('mousemove', (e) => {
            if (isGameOver) return;
            const rect = canvas.getBoundingClientRect();
            mouseX = e.clientX - rect.left;
        });
        
        canvas.addEventListener('click', (e) => {
            if (isGameOver || currentBall) return;
            
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            
            // ボールを落とす
            dropBall(x);
        });
        
        // タッチ対応
        canvas.addEventListener('touchmove', (e) => {
            if (isGameOver) return;
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            mouseX = e.touches[0].clientX - rect.left;
        });
        
        canvas.addEventListener('touchend', (e) => {
            if (isGameOver || currentBall) return;
            e.preventDefault();
            
            const rect = canvas.getBoundingClientRect();
            const x = e.changedTouches[0].clientX - rect.left;
            
            dropBall(x);
        });
        
        // ボールを落とす
        function dropBall(x) {
            const wallThickness = getWallThickness();
            const radius = getBallSize(nextBallType);
            
            // 壁から離れた位置に制限
            x = Math.max(wallThickness + radius, Math.min(canvas.width - wallThickness - radius, x));
            
            currentBall = new Ball(x, 50, nextBallType);
            balls.push(currentBall);
            
            // ゲームオーバー判定を遅らせる（180フレーム = 約3秒）
            checkGameOverDelay = 180;
            
            // 次のボールを準備
            nextBallType = getRandomBallType();
            updateNextPreview();
            
            // 少し待ってから次のボールを落とせるように
            setTimeout(() => {
                currentBall = null;
            }, 500);
        }
        
        // ゲームループ
        function gameLoop() {
            const wallThickness = getWallThickness();
            const gameLineY = getGameLineY();
            
            // 背景をクリア
            ctx.fillStyle = '#FFF8E7';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // 木製の壁を描画
            ctx.fillStyle = '#D2B48C';
            ctx.fillRect(0, 0, wallThickness, canvas.height); // 左壁
            ctx.fillRect(canvas.width - wallThickness, 0, wallThickness, canvas.height); // 右壁
            ctx.fillRect(0, canvas.height - wallThickness, canvas.width, wallThickness); // 床
            
            // 壁の木目模様
            ctx.strokeStyle = '#8B7355';
            ctx.lineWidth = 2;
            for (let i = 0; i < 8; i++) {
                ctx.beginPath();
                ctx.moveTo(wallThickness / 2, i * canvas.height / 8);
                ctx.lineTo(wallThickness / 2, (i + 1) * canvas.height / 8);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(canvas.width - wallThickness / 2, i * canvas.height / 8);
                ctx.lineTo(canvas.width - wallThickness / 2, (i + 1) * canvas.height / 8);
                ctx.stroke();
            }
            
            // ゲームオーバーラインを描画（壁の内側だけ）
            ctx.strokeStyle = 'rgba(255, 107, 107, 0.6)';
            ctx.lineWidth = 3;
            ctx.setLineDash([10, 5]);
            ctx.beginPath();
            ctx.moveTo(wallThickness, gameLineY);
            ctx.lineTo(canvas.width - wallThickness, gameLineY);
            ctx.stroke();
            ctx.setLineDash([]);
            
            if (!isGameOver) {
                // ボールを更新
                for (let ball of balls) {
                    ball.update();
                }
                
                // 衝突判定
                handleCollisions();
                
                // ゲームオーバー判定
                if (checkGameOver()) {
                    isGameOver = true;
                    showGameOver();
                }
            }
            
            // ボールを描画
            for (let ball of balls) {
                ball.draw();
            }
            
            // 次のボールのプレビュー（マウス位置）
            if (!isGameOver && !currentBall) {
                const radius = getBallSize(nextBallType);
                const x = Math.max(wallThickness + radius, Math.min(canvas.width - wallThickness - radius, mouseX));
                
                ctx.save();
                ctx.globalAlpha = 0.5;
                ctx.translate(x, 50);
                
                // プレビューボールの描画
                if (fruitImageObjects[nextBallType]) {
                    ctx.drawImage(
                        fruitImageObjects[nextBallType],
                        -radius, -radius,
                        radius * 2, radius * 2
                    );
                } else {
                    // デフォルトのプレビュー
                    const gradient = ctx.createRadialGradient(
                        -radius * 0.3, -radius * 0.3, 0,
                        0, 0, radius
                    );
                    gradient.addColorStop(0, lightenColorUtil(BALL_COLORS[nextBallType], 40));
                    gradient.addColorStop(1, BALL_COLORS[nextBallType]);
                    
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(0, 0, radius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // 数字
                    ctx.fillStyle = 'white';
                    ctx.font = `bold ${radius * 0.6}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(nextBallType, 0, 0);
                }
                
                ctx.restore();
            }
            
            requestAnimationFrame(gameLoop);
        }
        
        // ユーティリティ関数
        function lightenColorUtil(color, percent) {
            const num = parseInt(color.replace("#",""), 16);
            const amt = Math.round(2.55 * percent);
            const R = (num >> 16) + amt;
            const G = (num >> 8 & 0x00FF) + amt;
            const B = (num & 0x0000FF) + amt;
            return "#" + (0x1000000 + (R<255?R<1?0:R:255)*0x10000 +
                (G<255?G<1?0:G:255)*0x100 + (B<255?B<1?0:B:255))
                .toString(16).slice(1);
        }
        
        // ゲームオーバー表示
        function showGameOver() {
            document.getElementById('finalScore').textContent = score;
            document.getElementById('gameOver').style.display = 'block';
        }
        
        // リスタート
        document.getElementById('restartBtn').addEventListener('click', () => {
            balls = [];
            score = 0;
            isGameOver = false;
            currentBall = null;
            nextBallType = getRandomBallType();
            checkGameOverDelay = 0;
            
            updateScore();
            updateNextPreview();
            document.getElementById('gameOver').style.display = 'none';
        });
        
        // ゲーム開始
        nextBallType = getRandomBallType();
        updateNextPreview();
        updateScore();
        gameLoop();
    </script>
</body>
</html>
